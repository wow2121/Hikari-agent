# 小光AI助手 - 开发指南

## 概述

本文档为开发者提供小光AI助手项目的开发指南，包括代码规范、扩展开发、测试方法和调试技巧。

## 项目结构

### 目录结构说明

```
app/src/main/java/com/xiaoguang/assistant/
├── domain/                    # 领域层 - 核心业务逻辑
│   ├── flow/                 # 心流系统
│   │   ├── FlowLoop.kt       # 主控循环
│   │   ├── layer/            # 四层架构
│   │   │   ├── PerceptionLayer.kt
│   │   │   ├── ThinkingLayer.kt
│   │   │   ├── DecisionLayer.kt
│   │   │   └── ActionLayer.kt
│   │   └── model/            # 数据模型
│   ├── memory/               # 记忆系统
│   │   ├── UnifiedMemorySystem.kt
│   │   ├── reconstruction/   # 记忆重构
│   │   └── models/
│   ├── knowledge/            # 知识系统
│   │   ├── CharacterBook.kt
│   │   └── WorldBook.kt
│   ├── social/               # 社交系统
│   ├── schedule/             # 日程系统
│   └── tools/                # 工具系统
├── data/                     # 数据层 - 数据访问和存储
│   ├── repository/           # 数据仓库
│   ├── local/                # 本地存储
│   └── remote/               # 远程数据源
├── ui/                       # UI层 - 界面和用户交互
│   ├── screen/               # 界面屏幕
│   ├── component/            # 可复用组件
│   └── theme/                # 主题和样式
└── di/                       # 依赖注入配置
```

### 架构模式

项目采用 **Clean Architecture** + **MVVM** 架构：

- **领域层**: 包含核心业务逻辑，不依赖任何框架
- **数据层**: 负责数据访问和存储，实现领域层接口
- **UI层**: 负责用户界面和交互，使用Jetpack Compose
- **依赖注入**: 使用Hilt管理依赖关系

## 代码规范

### 命名规范

#### 包命名

```kotlin
// 按功能模块划分
com.xiaoguang.assistant.domain.flow
com.xiaoguang.assistant.domain.memory
com.xiaoguang.assistant.data.repository
com.xiaoguang.assistant.ui.screen

// 按架构层次划分
com.xiaoguang.assistant.domain
com.xiaoguang.assistant.data
com.xiaoguang.assistant.ui
```

#### 类命名

```kotlin
// 接口 - 名词 + 接口类型
interface MemorySystem
interface FlowLayer

// 实现类 - 名词 + 实现类型
class UnifiedMemorySystemImpl : MemorySystem
class ThinkingLayerImpl : ThinkingLayer

// 数据类 - 名词 + 数据类型
data class MemoryQuery
data class SpeakDecision

// 枚举类 - 名词 + 枚举类型
enum class MemoryCategory
enum class PersonalityType
```

#### 函数命名

```kotlin
// 查询函数 - 动词 + 名词
suspend fun queryMemories(query: MemoryQuery): List<Memory>
fun getRelationship(personName: String): Relationship?

// 操作函数 - 动词 + 名词
suspend fun storeMemory(memory: Memory): MemoryResult
fun updateRelationship(interaction: Interaction): UpdateResult

// 判断函数 - is/has/should + 形容词
fun shouldSpeak(perception: Perception): Boolean
fun hasConflicts(memory: Memory): Boolean
```

### 代码风格

#### Kotlin最佳实践

```kotlin
// 使用数据类表示不可变数据
data class Memory(
    val id: String,
    val content: String,
    val category: MemoryCategory,
    val timestamp: Long
)

// 使用密封类表示有限的状态
sealed class MemoryResult {
    data class Success(val memory: Memory) : MemoryResult()
    data class Conflict(val conflicts: List<MemoryConflict>) : MemoryResult()
    data class Error(val message: String) : MemoryResult()
}

// 使用扩展函数增强可读性
fun List<Memory>.filterByCategory(category: MemoryCategory): List<Memory> {
    return filter { it.category == category }
}

// 使用作用域函数简化代码
memory?.let {
    processMemory(it)
    updateCache(it)
}
```

#### 协程使用规范

```kotlin
// 使用suspend函数表示异步操作
suspend fun processMemory(memory: Memory): MemoryResult {
    return withContext(Dispatchers.IO) {
        // IO密集型操作
        val analysis = analyzeMemory(memory)
        storeMemory(analysis)
    }
}

// 使用async进行并行操作
suspend fun loadAllData(): CombinedData {
    val memoriesDeferred = async { memorySystem.queryRecentMemories() }
    val relationshipsDeferred = async { socialSystem.getCurrentRelationships() }
    val knowledgeDeferred = async { knowledgeSystem.getRelevantKnowledge() }

    return CombinedData(
        memories = memoriesDeferred.await(),
        relationships = relationshipsDeferred.await(),
        knowledge = knowledgeDeferred.await()
    )
}

// 错误处理
suspend fun safeOperation(): Result<Data> = try {
    Result.success(performOperation())
} catch (e: Exception) {
    Result.failure(e)
}
```

## 扩展开发

### 添加新的心流层

#### 1. 定义接口

```kotlin
interface CustomLayer {
    suspend fun process(perception: Perception, thoughts: List<InnerThought>): CustomResult
}

data class CustomResult(
    val processedThoughts: List<InnerThought>,
    val additionalData: Map<String, Any>
)
```

#### 2. 实现接口

```kotlin
class CustomLayerImpl(
    private val dependency: SomeDependency
) : CustomLayer {

    override suspend fun process(
        perception: Perception,
        thoughts: List<InnerThought>
    ): CustomResult {
        // 实现自定义逻辑
        val processedThoughts = thoughts.map { processThought(it) }
        val additionalData = analyzeAdditionalData(perception)

        return CustomResult(processedThoughts, additionalData)
    }

    private suspend fun processThought(thought: InnerThought): InnerThought {
        // 处理单个想法
        return thought.copy(
            content = enhanceThoughtContent(thought.content),
            confidence = adjustConfidence(thought.confidence)
        )
    }
}
```

#### 3. 集成到心流系统

```kotlin
class EnhancedFlowLoop(
    private val perceptionLayer: PerceptionLayer,
    private val thinkingLayer: ThinkingLayer,
    private val customLayer: CustomLayer,  // 新增层
    private val decisionLayer: DecisionLayer,
    private val actionLayer: ActionLayer
) {
    suspend fun start() {
        while (isRunning) {
            val perception = perceptionLayer.perceive()
            val thoughts = thinkingLayer.think(perception)

            // 使用自定义层处理
            val customResult = customLayer.process(perception, thoughts)

            val decision = decisionLayer.decide(perception, customResult.processedThoughts)

            if (decision.shouldSpeak) {
                actionLayer.act(decision)
            }

            delay(FLOW_INTERVAL_MS)
        }
    }
}
```

### 添加新的记忆类型

#### 1. 定义记忆类别

```kotlin
enum class MemoryCategory {
    CONVERSATION,
    EVENT,
    PREFERENCE,
    CUSTOM_TYPE  // 新增类型
}
```

#### 2. 实现记忆处理器

```kotlin
class CustomMemoryProcessor : MemoryProcessor {

    override fun canProcess(memory: Memory): Boolean {
        return memory.category == MemoryCategory.CUSTOM_TYPE
    }

    override suspend fun process(memory: Memory): ProcessedMemory {
        // 自定义处理逻辑
        val enhancedContent = enhanceMemoryContent(memory.content)
        val extractedEntities = extractCustomEntities(memory)
        val calculatedImportance = calculateCustomImportance(memory)

        return ProcessedMemory(
            original = memory,
            enhancedContent = enhancedContent,
            entities = extractedEntities,
            importance = calculatedImportance
        )
    }

    private fun enhanceMemoryContent(content: String): String {
        // 实现内容增强逻辑
        return "[Custom] $content"
    }
}
```

#### 3. 注册处理器

```kotlin
class ExtendedMemorySystem(
    private val baseSystem: UnifiedMemorySystem
) : UnifiedMemorySystem {

    private val customProcessors = listOf(
        CustomMemoryProcessor()
    )

    override suspend fun storeMemory(memory: Memory): MemoryResult {
        // 应用自定义处理器
        val processedMemory = customProcessors
            .find { it.canProcess(memory) }
            ?.process(memory)
            ?: ProcessedMemory.from(memory)

        return baseSystem.storeMemory(processedMemory.toMemory())
    }
}
```

### 添加新的工具

#### 1. 定义工具接口

```kotlin
interface CustomTool {
    val name: String
    val description: String
    val parameters: List<ToolParameter>

    suspend fun execute(parameters: Map<String, Any>, context: ToolContext): ToolResult
}

data class ToolParameter(
    val name: String,
    val type: ParameterType,
    val description: String,
    val required: Boolean = true
)
```

#### 2. 实现工具

```kotlin
class WeatherTool : CustomTool {
    override val name = "weather_query"
    override val description = "查询指定城市的天气信息"

    override val parameters = listOf(
        ToolParameter(
            name = "city",
            type = ParameterType.STRING,
            description = "城市名称",
            required = true
        )
    )

    override suspend fun execute(
        parameters: Map<String, Any>,
        context: ToolContext
    ): ToolResult {
        return try {
            val city = parameters["city"] as String
            val weather = fetchWeatherData(city)

            ToolResult(
                success = true,
                result = weather,
                error = null,
                executionTime = 0
            )
        } catch (e: Exception) {
            ToolResult(
                success = false,
                result = null,
                error = "天气查询失败: ${e.message}",
                executionTime = 0
            )
        }
    }

    private suspend fun fetchWeatherData(city: String): WeatherData {
        // 实现天气数据获取逻辑
        // ...
    }
}
```

#### 3. 注册工具

```kotlin
class ExtendedToolSystem(
    private val baseSystem: McpToolSystem
) : McpToolSystem {

    private val customTools = listOf(
        WeatherTool()
    )

    override suspend fun executeTool(request: ToolExecutionRequest): ToolExecutionResult {
        // 检查是否为自定义工具
        val customTool = customTools.find { it.name == request.toolName }
        if (customTool != null) {
            return customTool.execute(request.parameters, request.context)
        }

        // 否则使用基础系统
        return baseSystem.executeTool(request)
    }

    override suspend fun getAvailableTools(): List<ToolDefinition> {
        val baseTools = baseSystem.getAvailableTools()
        val customToolDefinitions = customTools.map { it.toToolDefinition() }

        return baseTools + customToolDefinitions
    }
}
```

## 测试指南

### 单元测试

#### 记忆系统测试

```kotlin
@HiltAndroidTest
class MemorySystemTest {

    @get:Rule
    val hiltRule = HiltAndroidRule(this)

    @Inject
    lateinit var memorySystem: UnifiedMemorySystem

    @Test
    fun `test memory storage and retrieval`() = runTest {
        // 准备测试数据
        val testMemory = Memory(
            id = "test-1",
            content = "测试记忆内容",
            category = MemoryCategory.CONVERSATION,
            timestamp = System.currentTimeMillis()
        )

        // 执行存储
        val storeResult = memorySystem.storeMemory(testMemory)

        // 验证存储结果
        assertTrue(storeResult.success)
        assertNotNull(storeResult.memoryId)

        // 执行查询
        val query = MemoryQuery(semantic = "测试")
        val memories = memorySystem.queryMemories(query)

        // 验证查询结果
        assertTrue(memories.isNotEmpty())
        assertEquals(testMemory.content, memories.first().memory.content)
    }

    @Test
    fun `test memory conflict detection`() = runTest {
        // 准备冲突的记忆
        val memory1 = createMemory("我喜欢红色", MemoryCategory.PREFERENCE)
        val memory2 = createMemory("我其实更喜欢蓝色", MemoryCategory.PREFERENCE)

        // 存储第一个记忆
        memorySystem.storeMemory(memory1)

        // 存储第二个记忆，应该检测到冲突
        val result = memorySystem.storeMemory(memory2)

        // 验证冲突检测
        assertTrue(result.conflicts?.isNotEmpty() ?: false)
        assertNotNull(result.reconstruction)
    }
}
```

#### 心流系统测试

```kotlin
@Test
fun `test flow decision making`() = runTest {
    // 准备测试感知数据
    val perception = Perception(
        environment = createTestEnvironment(),
        conversation = createTestConversation(),
        social = createTestSocialRelations(),
        emotion = UserEmotion.HAPPY
    )

    // 准备测试想法
    val thoughts = listOf(
        InnerThought("主人看起来很开心", ThoughtType.OBSERVATION, 0.8f)
    )

    // 执行决策
    val decision = decisionLayer.decide(perception, thoughts)

    // 验证决策结果
    assertTrue(decision.shouldSpeak)
    assertNotNull(decision.content)
    assertEquals(ToneType.FRIENDLY, decision.tone)
}
```

### 集成测试

```kotlin
@HiltAndroidTest
class IntegrationTest {

    @Inject
    lateinit var flowSystem: FlowSystem

    @Inject
    lateinit var memorySystem: UnifiedMemorySystem

    @Test
    fun `test complete flow cycle`() = runTest {
        // 启动心流系统
        flowSystem.start()

        // 等待几个循环
        delay(10000)

        // 验证系统状态
        val systemStatus = flowSystem.getSystemStatus()
        assertTrue(systemStatus.isRunning)
        assertTrue(systemStatus.cycleCount > 0)

        // 停止系统
        flowSystem.stop()
    }
}
```

### UI测试

```kotlin
@HiltAndroidTest
class MainScreenTest {

    @get:Rule
    val composeTestRule = createComposeRule()

    @Test
    fun `test main screen display`() {
        composeTestRule.setContent {
            AssistantTheme {
                MainScreen()
            }
        }

        // 验证界面元素
        composeTestRule.onNodeWithText("小光AI助手").assertExists()
        composeTestRule.onNodeWithContentDescription("语音按钮").assertExists()
        composeTestRule.onNodeWithContentDescription("设置按钮").assertExists()
    }

    @Test
    fun `test conversation display`() {
        val testConversations = listOf(
            Conversation("你好", "主人", System.currentTimeMillis()),
            Conversation("今天天气怎么样？", "小光", System.currentTimeMillis())
        )

        composeTestRule.setContent {
            AssistantTheme {
                ConversationScreen(conversations = testConversations)
            }
        }

        // 验证对话显示
        composeTestRule.onNodeWithText("你好").assertExists()
        composeTestRule.onNodeWithText("今天天气怎么样？").assertExists()
    }
}
```

## 调试技巧

### 日志调试

```kotlin
// 使用结构化日志
class DebugLogger {
    companion object {
        fun logFlowCycle(cycleId: Long, perception: Perception, decision: SpeakDecision) {
            Log.d("FlowSystem", """
                |Cycle: $cycleId
                |Environment: ${perception.environment.location}
                |Conversation: ${perception.conversation?.content}
                |Decision: ${decision.shouldSpeak} - ${decision.content}
                |Confidence: ${decision.confidence}
            """.trimMargin())
        }

        fun logMemoryOperation(operation: String, memory: Memory, result: Any?) {
            Log.d("MemorySystem", """
                |Operation: $operation
                |Memory: ${memory.content}
                |Category: ${memory.category}
                |Result: $result
            """.trimMargin())
        }
    }
}
```

### 性能监控

```kotlin
class PerformanceMonitor {

    fun monitorFlowCycle(block: suspend () -> Unit) {
        val startTime = System.currentTimeMillis()

        try {
            block()
        } finally {
            val duration = System.currentTimeMillis() - startTime

            if (duration > 1000) {
                Log.w("Performance", "Flow cycle took ${duration}ms")
            }
        }
    }

    fun monitorMemoryQuery(query: MemoryQuery, block: suspend () -> List<Memory>) {
        val startTime = System.currentTimeMillis()

        val result = block()
        val duration = System.currentTimeMillis() - startTime

        Log.d("Performance", "Memory query took ${duration}ms, returned ${result.size} results")

        return result
    }
}
```

### 调试工具

#### 内存调试

```kotlin
// 检查内存泄漏
class MemoryLeakDetector {

    private val trackedObjects = mutableMapOf<String, WeakReference<Any>>()

    fun trackObject(name: String, obj: Any) {
        trackedObjects[name] = WeakReference(obj)
    }

    fun checkLeaks() {
        val leaks = trackedObjects.filter { it.value.get() == null }
        if (leaks.isNotEmpty()) {
            Log.e("MemoryLeak", "Detected ${leaks.size} potential memory leaks")
            leaks.keys.forEach { Log.e("MemoryLeak", "Leaked: $it") }
        }
    }
}
```

#### 网络调试

```kotlin
// 网络请求调试
class NetworkDebugInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        val startTime = System.currentTimeMillis()

        Log.d("Network", "--> ${request.method} ${request.url}")

        try {
            val response = chain.proceed(request)
            val duration = System.currentTimeMillis() - startTime

            Log.d("Network", "<-- ${response.code} ${request.url} (${duration}ms)")

            return response
        } catch (e: IOException) {
            Log.e("Network", "<-- FAILED ${request.url} - ${e.message}")
            throw e
        }
    }
}
```

## 部署指南

### 发布准备

1. **代码检查**
   ```bash
   # 运行静态代码分析
   ./gradlew lint

   # 运行所有测试
   ./gradlew test
   ./gradlew connectedAndroidTest
   ```

2. **性能优化**
   ```bash
   # 启用代码混淆
   # 在 build.gradle.kts 中设置 minifyEnabled = true

   # 启用资源压缩
   # 在 build.gradle.kts 中设置 shrinkResources = true
   ```

3. **安全检查**
   ```bash
   # 检查敏感信息
   # 确保没有硬编码的API密钥
   # 验证权限配置
   ```

### 发布流程

1. **构建发布版本**
   ```bash
   ./gradlew assembleRelease
   ```

2. **签名APK**
   ```bash
   # 使用Android Studio或命令行工具签名
   jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 \
     -keystore my-release-key.keystore \
     app-release-unsigned.apk alias_name
   ```

3. **优化APK**
   ```bash
   # 使用zipalign优化
   zipalign -v 4 app-release-unsigned.apk app-release.apk
   ```

4. **发布到应用商店**
   - 准备应用截图和描述
   - 填写应用信息
   - 提交审核

通过遵循这个开发指南，开发者可以高效地进行小光AI助手项目的开发、测试和部署工作。