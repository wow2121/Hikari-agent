# 小光AI助手 - 模块详细说明

## 概述

本文档详细描述小光AI助手系统的各个核心模块的实现细节、算法原理和关键代码逻辑。

## 心流系统模块

### FlowLoop (主控循环)

**文件位置**: `domain/flow/FlowLoop.kt`

#### 核心实现

```kotlin
class FlowLoop(
    private val perceptionLayer: PerceptionLayer,
    private val thinkingLayer: ThinkingLayer,
    private val decisionLayer: DecisionLayer,
    private val actionLayer: ActionLayer,
    private val config: FlowConfig
) {
    private var isRunning = false

    suspend fun start() {
        isRunning = true
        while (isRunning) {
            try {
                // 1. 感知环境
                val perception = perceptionLayer.perceive()

                // 2. 生成想法
                val thoughts = thinkingLayer.think(perception)

                // 3. 决策是否发言
                val decision = decisionLayer.decide(perception, thoughts)

                // 4. 执行行动
                if (decision.shouldSpeak) {
                    actionLayer.act(decision)
                }

                // 5. 等待下一个循环
                delay(config.baseIntervalMs)
            } catch (e: Exception) {
                // 错误处理和日志记录
                logError("FlowLoop error", e)
                delay(config.baseIntervalMs)
            }
        }
    }

    fun stop() {
        isRunning = false
    }
}
```

#### 关键特性

1. **持续运行**: 每3秒自动执行完整的心流循环
2. **错误恢复**: 单次循环错误不影响整体运行
3. **资源管理**: 使用协程避免阻塞主线程
4. **配置驱动**: 循环间隔等参数可配置

### PerceptionLayer (感知层)

**文件位置**: `domain/flow/layer/PerceptionLayer.kt`

#### 感知数据整合

```kotlin
class PerceptionLayerImpl(
    private val environmentService: EnvironmentService,
    private val conversationService: ConversationService,
    private val socialService: SocialService,
    private val emotionService: EmotionService
) : PerceptionLayer {

    override suspend fun perceive(): Perception {
        // 并行获取各种感知数据
        val environmentDeferred = async { environmentService.getCurrentEnvironment() }
        val conversationDeferred = async { conversationService.getLatestConversation() }
        val socialDeferred = async { socialService.getCurrentSocialContext() }
        val emotionDeferred = async { emotionService.detectCurrentEmotion() }

        // 等待所有数据
        return Perception(
            environment = environmentDeferred.await(),
            conversation = conversationDeferred.await(),
            social = socialDeferred.await(),
            emotion = emotionDeferred.await(),
            temporal = TemporalContext(System.currentTimeMillis())
        )
    }
}
```

#### 感知数据类型

- **环境数据**: 位置、时间、天气、噪音水平、在场人物
- **对话数据**: 最新对话内容、说话人、情感
- **社交数据**: 当前社交关系、互动历史
- **情感数据**: 用户当前情绪状态

### ThinkingLayer (思考层)

**文件位置**: `domain/flow/layer/ThinkingLayer.kt`

#### 思考生成算法

```kotlin
class ThinkingLayerImpl(
    private val llmService: LlmService,
    private val memorySystem: UnifiedMemorySystem,
    private val knowledgeSystem: KnowledgeSystem
) : ThinkingLayer {

    override suspend fun think(perception: Perception): List<InnerThought> {
        // 1. 构建思考上下文
        val context = buildThinkingContext(perception)

        // 2. 调用LLM生成想法
        val thoughtsJson = llmService.generateThoughts(context)

        // 3. 解析和验证想法
        return parseAndValidateThoughts(thoughtsJson, perception)
    }

    private suspend fun buildThinkingContext(perception: Perception): ThinkingContext {
        // 查询相关记忆
        val relevantMemories = memorySystem.queryMemories(
            MemoryQuery(
                semantic = extractKeyTopics(perception),
                limit = 20
            )
        )

        return ThinkingContext(
            perception = perception,
            memories = relevantMemories,
            knowledge = knowledgeSystem.getRelevantKnowledge(perception),
            currentTime = System.currentTimeMillis()
        )
    }
}
```

#### 思考类型分类

- **观察型思考**: 对环境变化的直接反应
- **反思型思考**: 对过去事件的深度思考
- **好奇心思考**: 对未知事物的探索欲望
- **关心型思考**: 对用户状态的关怀
- **提醒型思考**: 对重要事项的提醒
- **建议型思考**: 对用户行为的建议

### DecisionLayer (决策层)

**文件位置**: `domain/flow/layer/DecisionLayer.kt`

#### 发言决策算法

```kotlin
class DecisionLayerImpl(
    private val llmService: LlmService,
    private val socialSystem: SocialSystem,
    private val config: FlowConfig
) : DecisionLayer {

    override suspend fun decide(
        perception: Perception,
        thoughts: List<InnerThought>
    ): SpeakDecision {
        // 1. 计算基础发言概率
        val baseProbability = calculateBaseProbability(perception, thoughts)

        // 2. 应用社交调节因子
        val socialFactor = calculateSocialFactor(perception)

        // 3. 应用时间调节因子
        val timeFactor = calculateTimeFactor(perception.temporal)

        // 4. 计算最终概率
        val finalProbability = baseProbability * socialFactor * timeFactor

        // 5. 与阈值比较
        val threshold = getSpeakThreshold(perception)
        val shouldSpeak = finalProbability >= threshold

        // 6. 如果需要发言，生成内容
        val content = if (shouldSpeak) {
            generateSpeechContent(perception, thoughts, finalProbability)
        } else null

        return SpeakDecision(
            shouldSpeak = shouldSpeak,
            content = content,
            tone = determineTone(perception, thoughts),
            confidence = finalProbability,
            timing = determineTiming(perception),
            targetPerson = determineTargetPerson(perception)
        )
    }

    private fun getSpeakThreshold(perception: Perception): Float {
        val personType = determinePersonType(perception)
        return config.speakThresholds[personType] ?: 0.8f
    }
}
```

#### 决策因子

1. **基础概率**: 基于想法重要性和相关性
2. **社交因子**: 基于在场人物和关系
3. **时间因子**: 基于时间和场景适宜性
4. **情感因子**: 基于用户当前情绪状态

### ActionLayer (行动层)

**文件位置**: `domain/flow/layer/ActionLayer.kt`

#### 行动执行逻辑

```kotlin
class ActionLayerImpl(
    private val speechService: SpeechService,
    private val toolSystem: ToolSystem,
    private val memorySystem: UnifiedMemorySystem
) : ActionLayer {

    override suspend fun act(decision: SpeakDecision) {
        // 1. 执行发言
        if (decision.content != null) {
            speechService.speak(decision.content, decision.tone)
        }

        // 2. 执行工具调用
        decision.toolCalls?.forEach { toolCall ->
            val result = toolSystem.executeTool(toolCall)
            handleToolResult(result, decision)
        }

        // 3. 记录行动到记忆
        recordActionToMemory(decision)
    }

    private suspend fun recordActionToMemory(decision: SpeakDecision) {
        val memory = Memory(
            id = generateMemoryId(),
            content = "主动发言: ${decision.content}",
            category = MemoryCategory.ACTION,
            metadata = MemoryMetadata(
                source = MemorySource.FLOW_SYSTEM,
                confidence = decision.confidence,
                importance = calculateActionImportance(decision),
                accessibility = 0.8f
            ),
            entities = extractEntitiesFromDecision(decision),
            emotions = extractEmotionsFromDecision(decision),
            timestamp = System.currentTimeMillis()
        )

        memorySystem.storeMemory(memory)
    }
}
```

## 声纹识别系统模块

### VoiceprintManager (声纹管理器)

**文件位置**: `domain/voiceprint/VoiceprintManager.kt`

#### 核心实现

```kotlin
@Singleton
class VoiceprintManager @Inject constructor(
    private val chromaAPI: ChromaAPI,
    private val featureExtractor: VoiceprintFeatureExtractor
) {
    companion object {
        private const val COLLECTION_NAME = "voiceprints"
        private const val SIMILARITY_THRESHOLD = 0.75f
        private const val MIN_SAMPLES = 3
    }

    /**
     * 注册新声纹
     * - 需要至少3个音频样本
     * - 计算平均特征向量提高鲁棒性
     * - 存储到ChromaDB
     */
    suspend fun registerVoiceprint(
        request: VoiceprintRegistrationRequest
    ): Result<VoiceprintProfile> {
        // 1. 验证样本数量
        if (request.audioSamples.size < MIN_SAMPLES) {
            return Result.failure(IllegalArgumentException("需要至少3个样本"))
        }

        // 2. 提取特征向量
        val features = request.audioSamples.map { audioData ->
            featureExtractor.extractFeature(audioData, request.sampleRate)
        }

        // 3. 计算平均特征
        val avgFeature = averageVectors(features)

        // 4. 计算置信度
        val confidence = calculateConfidence(features)

        // 5. 存储到ChromaDB
        saveToChroma(voiceprintProfile)

        return Result.success(voiceprintProfile)
    }

    /**
     * 识别说话人
     * - 提取查询音频的特征向量
     * - 在ChromaDB中查询最相似的声纹
     * - 根据相似度阈值判断是否匹配
     */
    suspend fun identifySpeaker(
        audioData: ByteArray,
        sampleRate: Int = 16000
    ): Result<VoiceprintIdentificationResult> {
        // 1. 提取特征
        val queryFeature = featureExtractor.extractFeature(audioData, sampleRate)

        // 2. ChromaDB查询
        val queryResult = queryChroma(queryFeature, nResults = 5)

        // 3. 判断相似度
        val topResult = queryResult.first()
        val similarity = 1f - (topResult.distance ?: 1f)

        if (similarity >= SIMILARITY_THRESHOLD) {
            // 匹配成功
            val profile = parseProfileFromMetadata(topResult)
            return Result.success(VoiceprintIdentificationResult(
                matched = true,
                profile = profile,
                similarity = similarity,
                speakerId = profile.personId
            ))
        } else {
            // 陌生人
            return Result.success(VoiceprintIdentificationResult(
                matched = false,
                profile = null,
                similarity = similarity,
                speakerId = "stranger_${System.currentTimeMillis()}"
            ))
        }
    }
}
```

#### 数据结构

```kotlin
data class VoiceprintProfile(
    val voiceprintId: String,        // UUID
    val personId: String,             // 人物ID
    val personName: String?,          // 人物名称
    val displayName: String,          // 显示名称
    val isMaster: Boolean = false,    // 是否主人
    val isStranger: Boolean = false,  // 是否陌生人
    val featureVector: FloatArray,    // 128维特征向量
    val sampleCount: Int = 0,         // 样本数量
    val confidence: Float = 0f,       // 置信度
    val createdAt: Long,
    val updatedAt: Long
)

data class VoiceprintIdentificationResult(
    val matched: Boolean,             // 是否匹配
    val profile: VoiceprintProfile?,  // 匹配的档案
    val similarity: Float,            // 相似度
    val confidence: Float,            // 置信度
    val speakerId: String             // 说话人ID
)
```

### VoiceprintFeatureExtractor (特征提取器)

**文件位置**: `domain/voiceprint/VoiceprintFeatureExtractor.kt`

#### 特征提取实现

```kotlin
class VoiceprintFeatureExtractor : AudioFeatureExtractor {
    override fun extractFeature(
        audioData: ByteArray,
        sampleRate: Int
    ): FloatArray {
        val samples = convertToSamples(audioData)

        // 1. MFCC特征 (40维)
        val mfccFeatures = extractMFCC(samples, sampleRate)

        // 2. 音高特征 (20维)
        val pitchFeatures = extractPitchFeatures(samples, sampleRate)

        // 3. 能量特征 (20维)
        val energyFeatures = extractEnergyFeatures(samples)

        // 4. 频谱特征 (48维)
        val spectralFeatures = extractSpectralFeatures(samples)

        // 5. 合并并标准化到128维
        val combinedFeatures = mfccFeatures + pitchFeatures +
                               energyFeatures + spectralFeatures
        return normalizeToFixedDimension(combinedFeatures, 128)
    }

    private fun extractMFCC(samples: FloatArray, sampleRate: Int): FloatArray {
        // MFCC算法实现
        // 1. 预加重
        // 2. 分帧
        // 3. 加窗 (汉明窗)
        // 4. FFT
        // 5. Mel滤波器组
        // 6. DCT
        return mfccCoefficients
    }

    private fun extractPitchFeatures(samples: FloatArray, sampleRate: Int): FloatArray {
        // 基频提取算法
        // 使用自相关法
        return pitchFeatures
    }

    private fun extractEnergyFeatures(samples: FloatArray): FloatArray {
        // 能量特征
        // - 短时能量
        // - 零交叉率
        // - 能量包络
        return energyFeatures
    }

    private fun extractSpectralFeatures(samples: FloatArray): FloatArray {
        // 频谱特征
        // - 频谱质心
        // - 频谱滚降点
        // - 频谱通量
        // - 频谱熵
        return spectralFeatures
    }
}
```

### NameInferenceService (名称推断服务)

**文件位置**: `domain/voiceprint/NameInferenceService.kt`

#### LLM驱动的名称推断

```kotlin
@Singleton
class NameInferenceService @Inject constructor(
    private val flowLlmService: FlowLlmService
) {
    /**
     * 从对话中推断陌生人的名字
     *
     * 示例场景：
     * A: "老王，你在吗？"
     * B (stranger_123): "诶，什么事？"
     * → 推断 stranger_123 可能是"老王"
     */
    suspend fun inferNameFromConversation(
        strangerId: String,
        recentMessages: List<Message>,
        conversationContext: String = ""
    ): NameInferenceResult {
        // 1. 提取最近5轮对话
        val recentConversation = recentMessages.takeLast(10)

        // 2. 构建上下文
        val conversationText = buildConversationText(recentConversation)
        val context = buildContext(strangerId, conversationContext)

        // 3. 调用LLM推断
        val result = flowLlmService.inferPersonName(
            conversation = conversationText,
            context = context,
            xiaoguangPersonality = XiaoguangPersonality.getPersonalitySystemPrompt()
        )

        return result
    }

    private fun buildContext(strangerId: String, extra: String): String {
        return """
        当前场景：检测到一位陌生人（ID: $strangerId）
        任务：从对话中推断这个人的名字

        推断规则：
        1. 关注对话中提到的人名
        2. 注意称呼语（如"老王"、"小李"）
        3. 如果陌生人回应了某个称呼，很可能就是Ta的名字
        4. 如果无法确定，返回null

        额外信息：$extra
        """.trimIndent()
    }
}
```

#### 推断结果数据结构

```kotlin
data class NameInferenceResult(
    val candidateNames: List<String>,  // 候选名字列表
    val confidence: Float,              // 置信度 (0.0-1.0)
    val reasoning: String,              // 推理过程
    val shouldRegister: Boolean         // 是否应该注册
)
```

### NewPersonRegistrationUseCase (新人注册协调器)

**文件位置**: `domain/voiceprint/NewPersonRegistrationUseCase.kt`

#### 9系统协调注册

```kotlin
@Singleton
class NewPersonRegistrationUseCase @Inject constructor(
    private val voiceprintManager: VoiceprintManager,
    private val characterBook: CharacterBook,
    private val unifiedSocialManager: UnifiedSocialManager,
    private val unifiedMemorySystem: UnifiedMemorySystem,
    private val relationshipGraphUseCase: RelationshipGraphUseCase,
    private val relationshipNetworkUseCase: RelationshipNetworkUseCase,
    private val worldBook: WorldBook,
    private val emotionService: EmotionService,
    private val identityRegistry: IdentityRegistry
) {
    /**
     * 注册新人物（协调9个系统）
     */
    suspend fun registerNewPerson(
        voiceprintProfile: VoiceprintProfile,
        recentMessages: List<Message>,
        context: String
    ): RegistrationResult {
        val checklist = mutableMapOf<String, Boolean>()

        try {
            // P0: 核心系统（必须成功）
            checklist["声纹识别"] = updateVoiceprintSystem(voiceprintProfile)
            checklist["角色档案"] = createCharacterProfile(voiceprintProfile)
            checklist["社交关系"] = createSocialRelation(voiceprintProfile)

            // P1: 重要系统
            checklist["记忆系统"] = createMemoryEntry(voiceprintProfile, recentMessages)
            checklist["关系图谱"] = createRelationshipNode(voiceprintProfile)

            // P2: 辅助系统
            checklist["第三方关系"] = analyzeThirdPartyRelations(voiceprintProfile, recentMessages)
            checklist["世界知识"] = updateWorldKnowledge(voiceprintProfile)

            // P3: 可选系统
            checklist["情绪服务"] = initEmotionProfile(voiceprintProfile)
            checklist["身份注册"] = registerIdentity(voiceprintProfile)

            val completionRate = checklist.values.count { it } / checklist.size.toFloat()

            return RegistrationResult(
                success = completionRate >= 0.6f,
                personId = voiceprintProfile.personId,
                checklist = checklist,
                completionRate = completionRate
            )
        } catch (e: Exception) {
            Timber.e(e, "新人注册失败")
            return RegistrationResult(
                success = false,
                personId = voiceprintProfile.personId,
                checklist = checklist,
                completionRate = 0f,
                error = e.message
            )
        }
    }
}
```

#### Checklist 模式

使用 Checklist 模式确保所有系统都被正确更新：

```kotlin
data class RegistrationResult(
    val success: Boolean,
    val personId: String,
    val checklist: Map<String, Boolean>,  // 每个系统的完成状态
    val completionRate: Float,            // 完成率 (0.0-1.0)
    val error: String? = null
)

// 示例输出：
RegistrationResult(
    success = true,
    personId = "person_abc123",
    checklist = mapOf(
        "声纹识别" to true,
        "角色档案" to true,
        "社交关系" to true,
        "记忆系统" to true,
        "关系图谱" to true,
        "第三方关系" to true,
        "世界知识" to false,  // 可选系统失败不影响整体
        "情绪服务" to true,
        "身份注册" to true
    ),
    completionRate = 0.89f  // 8/9 = 89%
)
```

#### 系统优先级

- **P0 (核心)**：声纹识别、角色档案、社交关系
  - 必须全部成功，否则整个注册失败
- **P1 (重要)**：记忆系统、关系图谱
  - 至少成功1个
- **P2 (辅助)**：第三方关系、世界知识
  - 可选，失败不影响整体
- **P3 (可选)**：情绪服务、身份注册
  - 完全可选

## 记忆系统模块

### UnifiedMemorySystem (统一记忆系统)

**文件位置**: `domain/memory/UnifiedMemorySystem.kt`

#### 记忆存储架构

```kotlin
class UnifiedMemorySystemImpl(
    private val worldBook: WorldBook,
    private val characterBook: CharacterBook,
    private val memoryCore: MemoryCore,
    private val reconstructionService: MemoryReconstructionService
) : UnifiedMemorySystem {

    override suspend fun queryMemories(query: MemoryQuery): List<RankedMemory> {
        // 并行查询三个子系统
        val worldMemories = async { worldBook.queryMemories(query) }
        val characterMemories = async { characterBook.queryMemories(query) }
        val coreMemories = async { memoryCore.queryMemories(query) }

        // 合并和排序结果
        val allMemories = worldMemories.await() +
                         characterMemories.await() +
                         coreMemories.await()

        return rankMemories(allMemories, query)
    }

    override suspend fun storeMemory(memory: Memory): MemoryResult {
        // 1. 检测冲突
        val conflicts = detectMemoryConflicts(memory)

        // 2. 如果有冲突，执行重构
        if (conflicts.isNotEmpty()) {
            val reconstructionResult = reconstructionService.reconstruct(conflicts)
            return MemoryResult(
                success = reconstructionResult.success,
                memoryId = reconstructionResult.updatedMemories.firstOrNull()?.id,
                conflicts = conflicts,
                reconstruction = reconstructionResult
            )
        }

        // 3. 无冲突，直接存储
        val storedMemory = storeToAppropriateSystem(memory)
        return MemoryResult(
            success = true,
            memoryId = storedMemory.id,
            conflicts = emptyList(),
            reconstruction = null
        )
    }

    private suspend fun storeToAppropriateSystem(memory: Memory): Memory {
        return when (memory.category) {
            MemoryCategory.CHARACTER -> characterBook.storeMemory(memory)
            MemoryCategory.WORLD -> worldBook.storeMemory(memory)
            else -> memoryCore.storeMemory(memory)
        }
    }
}
```

#### 记忆评分算法

```kotlin
private fun rankMemories(
    memories: List<Memory>,
    query: MemoryQuery
): List<RankedMemory> {
    return memories.map { memory ->
        val relevanceScore = calculateRelevanceScore(memory, query)
        val importanceScore = memory.metadata.importance
        val recencyScore = calculateRecencyScore(memory.timestamp)
        val emotionalScore = calculateEmotionalScore(memory.emotions)

        val totalScore = relevanceScore * 0.4f +
                        importanceScore * 0.3f +
                        recencyScore * 0.2f +
                        emotionalScore * 0.1f

        RankedMemory(memory, totalScore)
    }.sortedByDescending { it.score }
}
```

### MemoryReconstructionService (记忆重构服务)

**文件位置**: `domain/memory/reconstruction/MemoryReconstructionService.kt`

#### 重构策略选择

```kotlin
class MemoryReconstructionServiceImpl(
    private val llmService: LlmService
) : MemoryReconstructionService {

    override suspend fun reconstruct(conflicts: List<MemoryConflict>): ReconstructionResult {
        // 1. 分析冲突类型
        val conflictAnalysis = analyzeConflicts(conflicts)

        // 2. 选择重构策略
        val strategy = selectReconstructionStrategy(conflictAnalysis)

        // 3. 执行重构
        return strategy.execute(conflicts)
    }

    private suspend fun selectReconstructionStrategy(
        analysis: ConflictAnalysis
    ): ReconstructionStrategy {
        return when (analysis.primaryConflictType) {
            ConflictType.FACTUAL_CONTRADICTION -> FactualCorrectionStrategy(llmService)
            ConflictType.PARTIAL_UPDATE -> PartialUpdateStrategy(llmService)
            ConflictType.CONTEXT_ENHANCEMENT -> ContextEnhancementStrategy(llmService)
            ConflictType.EMOTIONAL_UPDATE -> EmotionalUpdateStrategy(llmService)
            ConflictType.MERGE_REQUIRED -> MergeStrategy(llmService)
            else -> DefaultReconstructionStrategy(llmService)
        }
    }
}
```

#### 重构策略类型

1. **事实修正策略**: 修正错误的事实信息
2. **部分更新策略**: 更新记忆的特定部分
3. **上下文增强策略**: 为记忆添加上下文信息
4. **情感更新策略**: 更新记忆的情感标签
5. **合并策略**: 合并相似的记忆

## 社交系统模块

### SocialSystem (社交系统)

**文件位置**: `domain/social/SocialSystem.kt`

#### 关系强度计算

```kotlin
class SocialSystemImpl(
    private val relationshipGraph: RelationshipGraph,
    private val llmService: LlmService
) : SocialSystem {

    override suspend fun updateRelationship(interaction: Interaction): UpdateResult {
        // 1. 计算互动影响
        val impact = calculateInteractionImpact(interaction)

        // 2. 更新关系强度
        val currentRelationship = getRelationship(interaction.person)
        val updatedRelationship = updateRelationshipStrength(
            currentRelationship,
            impact
        )

        // 3. 存储更新
        relationshipGraph.updateRelationship(
            interaction.person,
            updatedRelationship
        )

        // 4. 记录互动历史
        recordInteraction(interaction, updatedRelationship)

        return UpdateResult(
            success = true,
            relationshipChanges = mapOf(
                interaction.person to calculateChangeMagnitude(
                    currentRelationship,
                    updatedRelationship
                )
            ),
            newRelationships = detectNewRelationships(interaction)
        )
    }

    private fun calculateInteractionImpact(interaction: Interaction): InteractionImpact {
        val baseImpact = when (interaction.type) {
            InteractionType.POSITIVE_CONVERSATION -> 0.1f
            InteractionType.DEEP_CONVERSATION -> 0.15f
            InteractionType.HELPFUL_ACTION -> 0.2f
            InteractionType.NEGATIVE_INTERACTION -> -0.1f
            else -> 0.05f
        }

        // 应用情感调节
        val emotionFactor = when (interaction.emotion) {
            EmotionType.HAPPY -> 1.2f
            EmotionType.SAD -> 0.8f
            EmotionType.ANGRY -> 0.6f
            else -> 1.0f
        }

        // 应用时长调节
        val durationFactor = interaction.duration?.let {
            minOf(it / 60000.0f, 2.0f)
        } ?: 1.0f

        return InteractionImpact(
            intimacy = baseImpact * emotionFactor * durationFactor,
            trust = baseImpact * 0.8f * emotionFactor,
            affection = baseImpact * 1.1f * emotionFactor
        )
    }
}
```

#### 第三方关系提取

```kotlin
private suspend fun extractThirdPartyRelations(
    conversation: String,
    knownPeople: Set<String>
): List<ThirdPartyRelation> {
    // 1. 实体识别
    val entities = extractNamedEntities(conversation)

    // 2. 关系提取
    val relationTriples = extractRelationTriples(conversation, entities)

    // 3. 关系分类
    return relationTriples.map { triple ->
        val relationType = classifyRelationType(triple.relation)
        val confidence = calculateRelationConfidence(triple, conversation)

        ThirdPartyRelation(
            personA = triple.subject,
            personB = triple.object,
            relationType = relationType,
            confidence = confidence,
            source = conversation
        )
    }.filter { it.confidence > 0.7f }
}
```

## 知识系统模块

### CharacterBook (角色档案)

**文件位置**: `domain/knowledge/CharacterBook.kt`

#### 角色记忆管理

```kotlin
class CharacterBookImpl(
    private val storage: CharacterStorage,
    private val llmService: LlmService
) : CharacterBook {

    override suspend fun addCharacterMemory(
        personName: String,
        memory: CharacterMemory
    ): Boolean {
        // 1. 获取现有档案
        var profile = getCharacterProfile(personName) ?: createNewProfile(personName)

        // 2. 评估记忆价值
        val memoryValue = evaluateMemoryValue(memory, profile)

        // 3. 如果价值足够高，添加到档案
        if (memoryValue > MEMORY_VALUE_THRESHOLD) {
            profile = profile.copy(
                memories = profile.memories + memory,
                development = updateCharacterDevelopment(profile, memory)
            )

            // 4. 存储更新
            return storage.saveProfile(profile)
        }

        return false
    }

    private suspend fun evaluateMemoryValue(
        memory: CharacterMemory,
        profile: CharacterProfile
    ): Float {
        val semanticValue = calculateSemanticValue(memory.content)
        val emotionalValue = memory.emotionalWeight
        val relationalValue = calculateRelationalValue(memory, profile.relationships)
        val developmentalValue = calculateDevelopmentalValue(memory, profile.development)
        val practicalValue = calculatePracticalValue(memory)

        return semanticValue * 0.3f +
               emotionalValue * 0.25f +
               relationalValue * 0.2f +
               developmentalValue * 0.15f +
               practicalValue * 0.1f
    }
}
```

### WorldBook (世界知识)

**文件位置**: `domain/knowledge/WorldBook.kt`

#### 知识推理引擎

```kotlin
class WorldBookImpl(
    private val factStorage: FactStorage,
    private val inferenceEngine: InferenceEngine
) : WorldBook {

    override suspend fun queryWorldKnowledge(query: WorldQuery): List<WorldFact> {
        // 1. 直接查询
        val directFacts = factStorage.queryFacts(query)

        // 2. 推理生成新知识
        val inferredFacts = inferenceEngine.inferFacts(query, directFacts)

        // 3. 合并和去重
        return (directFacts + inferredFacts)
            .distinctBy { it.toTriple() }
            .sortedByDescending { it.confidence }
    }

    override suspend fun addWorldFact(fact: WorldFact): Boolean {
        // 1. 验证事实一致性
        val conflicts = detectFactConflicts(fact)

        // 2. 如果有冲突，需要人工或LLM裁决
        if (conflicts.isNotEmpty()) {
            val resolution = resolveFactConflicts(fact, conflicts)
            if (!resolution.shouldAdd) {
                return false
            }
        }

        // 3. 存储事实
        return factStorage.storeFact(fact)
    }
}
```

## 工具调用模块

### McpToolSystem (MCP工具系统)

**文件位置**: `domain/tools/McpToolSystem.kt`

#### 工具执行管理

```kotlin
class McpToolSystemImpl(
    private val toolRegistry: ToolRegistry,
    private val executionEngine: ToolExecutionEngine
) : McpToolSystem {

    override suspend fun executeTool(request: ToolExecutionRequest): ToolExecutionResult {
        // 1. 验证工具存在
        val tool = toolRegistry.getTool(request.toolName)
            ?: return ToolExecutionResult(
                success = false,
                result = null,
                error = "Tool not found: ${request.toolName}",
                executionTime = 0
            )

        // 2. 验证参数
        val validationResult = validateParameters(tool.parameters, request.parameters)
        if (!validationResult.isValid) {
            return ToolExecutionResult(
                success = false,
                result = null,
                error = "Parameter validation failed: ${validationResult.errors}",
                executionTime = 0
            )
        }

        // 3. 执行工具
        val startTime = System.currentTimeMillis()
        return try {
            val result = executionEngine.execute(tool, request.parameters, request.context)
            val executionTime = System.currentTimeMillis() - startTime

            ToolExecutionResult(
                success = true,
                result = result,
                error = null,
                executionTime = executionTime
            )
        } catch (e: Exception) {
            val executionTime = System.currentTimeMillis() - startTime
            ToolExecutionResult(
                success = false,
                result = null,
                error = "Execution failed: ${e.message}",
                executionTime = executionTime
            )
        }
    }

    override suspend fun registerTool(tool: ToolDefinition): Boolean {
        // 1. 验证工具定义
        if (!validateToolDefinition(tool)) {
            return false
        }

        // 2. 检查名称冲突
        if (toolRegistry.toolExists(tool.name)) {
            return false
        }

        // 3. 注册工具
        return toolRegistry.registerTool(tool)
    }
}
```

这些模块的详细实现展示了小光AI助手系统的高度智能化和模块化设计，每个模块都有清晰的职责和高效的算法实现。